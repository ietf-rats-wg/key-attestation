



RATS                                                        M. Ounsworth
Internet-Draft                                                   Entrust
Intended status: Standards Track                             J.-P. Fiset
Expires: 11 April 2026                                          Crypto4A
                                                           H. Tschofenig
                                                                   H-BRS
                                                             H. Birkholz
                                                          Fraunhofer SIT
                                                              M. Wiseman
                                                         Beyond Identity
                                                                N. Smith
                                                       Intel Corporation
                                                          8 October 2025


                  PKIX Evidence for Remote Attestation
              draft-ietf-rats-pkix-key-attestation-latest

Abstract

   This document specifies a vendor-agnostic format for evidence
   produced and verified within a PKIX context.  The evidence produced
   this way includes claims collected in a cryptographic module about
   itself and elements found within it such as cryptographic keys.

   One scenario envisaged is that the state inforamtion about the
   cryptographic module can be securely presented to a remote operator
   or auditor in a vendor-agnostic verifiable format.  A more complex
   scenario would be to submit this evidence to a Certification
   Authority to aid in determining whether the storage properties of
   this key meets the requirements of a given certificate profile.

   This specification also offers a format for requesting a
   cryptographic module to produce evidence tailored for expected use.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Remote ATtestation
   ProcedureS Working Group mailing list (rats@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/rats/.

   Source for this draft and an issue tracker can be found at
   https://github.com/hannestschofenig/key-attestation.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 11 April 2026.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Use Cases
     2.1.  Remote audit of a Hardware Security Module (HSM)
     2.2.  Key import and HSM clustering
     2.3.  Attesting subject of a certificate issuance
   3.  Terminology
   4.  Architecture and Conceptual Model
     4.1.  Attestation Key Certificate Chain
   5.  Information Model
     5.1.  Entity
     5.2.  Entity Type
     5.3.  Attribute and Attribute Type
   6.  Data Model
     6.1.  Platform Entity
       6.1.1.  vendor
       6.1.2.  hwserial
       6.1.3.  usermods
       6.1.4.  fipsboot, fipsver and fipslevel
       6.1.5.  envid
       6.1.6.  envdesc
     6.2.  Key Entity
       6.2.1.  identifier
       6.2.2.  spki
       6.2.3.  purpose
       6.2.4.  local
       6.2.5.  expiry
       6.2.6.  protection
     6.3.  Transaction Entity
       6.3.1.  nonce
       6.3.2.  timestamp
     6.4.  Additional Entity and Attribute Types
     6.5.  Encoding
   7.  Signing Procedure
   8.  Verification Procedure
   9.  Attestation Requests
   10. Appraisal Policies and Profiles
     10.1.  Key Import into an HSM
     10.2.  CA/Browser Forum Code-Signing
   11. ASN.1 Module
   12. IANA Considerations
   13. Security Considerations
     13.1.  Simple to Implement
     13.2.  Detached Signatures
     13.3.  Privacy
     13.4.  Authenticating and Authorizing the Presenter
     13.5.  Proof-of-Possession of Application Keys
   14. References
     14.1.  Normative References
     14.2.  Informative References
   Appendix A.  Samples
   Appendix B.  Acknowledgements
   Authors' Addresses

1.  Introduction

   This specification defines a format to transmit Evidence from an
   Attester to a Verifer within a PKIX environment.  This environment
   refers to the components generally used to support a PKI applications
   such as Certification Authorities and their clients, or more
   generally that relies upon X.509 certificates.  As outlined in
   Section 3, this specification uses a necessary mixture of RATS and
   PKI terminology in order to map concepts between the two domains.

   Within this specification, the concepts found in the Remote
   Attestation Procedures (RATS [RFC9334]) are mapped to the PKIX
   environment.  There are many other specifications that are based on
   the RATS architecture which offer formats to carry evidence.  This
   specification deals with peculiar aspects of the PKIX environment
   which make the existing evidence formats inappropriate:

   *  ASN.1 is the preferred encoding format in this environment.  X.509
      certificates ([RFC5280]) are used widely within this environment
      and the majority of tools are designed to support ASN.1.  There
      are many specialized devices (Hardware Security Modules) that are
      inflexible in adopting other formats because of internal
      constraints or validation difficulties.  This specification
      defines the format in ASN.1 to ease the adoption within the
      community.

   *  The claims within the Evidence are about internal entities such as
      "platforms" and "keys" which are not necessarily distinct from the
      Attesting Environment.  Therefore, although the concept of
      "measurement" is present within the PKIX environment, it is not
      always clear that you have one attesting environment measuring
      another distinct target environment the way it is envisioned in
      the RATS Architecture.  Therefore, the emphasis and structure of
      this specifications is adjusted accordingly.  Specifically, this
      specification assumes that the Attesting Environment and the
      Target Environment, as outlined in [RFC9334], are the same.  This
      might not be the case for all devices encountered, but is
      sufficient for the proposed specification.

   This specification also aims at providing an extensible framework to
   encode within Evidence claims other than the one proposed in this
   document.  This allows implementations to introduce new claims and
   their associated semantics to the Evidence produced.

2.  Use Cases

   This section covers use cases that motivated the development of this
   specification.

2.1.  Remote audit of a Hardware Security Module (HSM)

   There are situations where it is necessary to verify the current
   running state of a HSM as part of operational or auditing procedures.
   For example, there are devices that are certified to work in an
   environment only if certain versions of the firmware are loaded or
   only if application keys are protected in with a certain set of
   protection policies.

   The Evidence format offered by this specification allows a platform
   to report its firmware level along with other collected claims
   necessary in critical deployments.

2.2.  Key import and HSM clustering

   Consider that an HSM is being added to a logical HSM cluster.  Part
   of the onboarding process could involve the newly-added HSM providing
   proof of its running state, for example that it is a genuine device
   from the same manufacturer as the existing clustered HSMs, firmware
   patch level, FIPS mode, etc.  It could also be required to provide
   attestation of any system-level keys required for secure
   establishment of cluster communication.  In this scenario, the
   Verifier and Relying Party will be the other HSMs in the cluster
   deciding whether or not to admit the new HSM.

   A related scenario is when performing a key export-import across
   HSMs.  If the key is being imported with certain properties, for
   example an environment running in FIPS mode at FIPS Level 3, and the
   key is set to certain protection properties such as Non-Exportable
   and Dual-Control, then the HSM might wish to verify that the key was
   previously stored under the same properties.  This specification even
   provides a way to do this across HSM vendors.

   These scenarios motivate the design requirements to have an ASN.1
   based Evidence format and a data model that more closely matches
   typical HSM architecture since in both scenarios an HSM is acting as
   Verifier and Relying Party.

2.3.  Attesting subject of a certificate issuance

   Prior to a Certification Authority (CA) issuing a certificate on
   behalf of a subject, a number of procedures are required to verify
   that the subject of the certificate is associated with the key that
   is certified.  In some cases, such as issuing a code signing
   certificate [CNSA2.0], [codesigningbrsv3.8], a CA must ensure that
   the subject key is located in a Hardware Security Module (HSM).

   The Evidence format offered by this specification is designed to
   carry the information necessary for a CA to assess the location of
   the subject key along a number of commonly-required attributes.  More
   specifically, a CA could determine which HSM was used to generate the
   subject key, whether this device adheres to certain jurisdiction
   policies (such as FIPS mode) and the constraints applied to the key
   (such as whether is it extractable).

   For relatively simple HSM devices such as TPM-like devices, storage
   properties such as Extractable may always be true for all keys since
   the devices is not capable of key export and so the attestation could
   be essentially a hard-coded template asserting these immutable
   attributes.  However, more complex HSM devices require a more complex
   key attestation format that encompases the mutability of these
   attributes.  Also, the client requesting the key attestation might
   wish to scope-down the content of the key attestation, for example
   maybe the HSM contains many keys and only a certain subset are
   relevant for attesting the given transaction, or maybe only certain
   claims are relevant.  Lack of ability to scope-down the key
   attestation contents could, in some scenarios, constitute a grave
   privacy violation.  This motivates the design choice for a key
   attestation request mechanism.  The same objective could have been
   accomplished via a selective disclosure mechanism, however since an
   attestation request is necessary anyway to transmit an attestation
   nonce to the HSM, a standardized request format fits the usecase
   better and is generally simpler.

3.  Terminology

   This specification uses a necessary mixture of RATS and PKI
   terminology in order to map concepts between the two domains.

   The reader is assumed to be familiar with the vocabulary and concepts
   defined in the RATS architecture ([RFC9334]) such as Attester,
   Relying Party, Verifier.

   The reader is assumed to be familiar with common vocabulary and
   concepts defined in [RFC5280] such as certificate, signature,
   attribute, verifier.

   In order to avoid confusion, this document generally capitalizes RATS
   terms such as Attester, Relying Party, and Claim.  Therefore, for
   example, a "Verifier" should be assumed to be an entity that checks
   the validity of Evidence as per [RFC9334], whereas a "verifier" could
   be a more general refence, for example, to a PKI entity that checks
   the validity of an X.509 certificate or other digital signature as
   per [RFC5280].

   The following terms are used in this document:

   Application Key:
      An application key consists of a key hosted by a HSM (the
      platform) and intended to be used by a client of the HSM.  The
      access and operations on an application key is controlled by the
      HSM.  MikeO: I don't love that we have two "AK"s.  Maybe we can
      find a different term for this?

   Attestation Key (AK):
      Cryptographic key controlled solely by the Attester and used only
      for the purpose of producing Evidence.  In other words, it is used
      to digitally sign the claims collected by the Attester.

   Attestation Service (AttS):
      A logical module within the HSM that is responsible for generating
      Evidence compatible with the format outlined in this
      specification.  It collects claims from the platform and uses the
      Attestation Key to digitally sign the collection.

   Attester :
      The term Attester respects the definition offered in [RFC9334].
      In this specification, it is also interchangeable with "platform"
      or "HSM".

   Evidence :
      The term Evidence respects the definition offered in [RFC9334].
      In this specification, it refers to claims, encoded according to
      the format defined within this document, and signed using the
      Attestation Key.

   Hardware Security Module (HSM):
      A physical computing device that safeguards and manages secrets
      (most importantly cryptographic keys), and performs cryptographic
      operations based on those secrets.  This specification takes a
      broad definition of what counts as an HSM to include smartcards,
      USB tokens, TPMs, cryptographic co-processors (PCI cards) and
      "enterprise-grade" or "cloud-service grade" HSMs (possibly rack
      mounted).  In this specification, it is interchangeable with
      "platform" or "Attester".

   Key Attestation:
      Process of producing Evidence containing claims pertaining to
      application keys found within a HSM.  In general, the claims
      includes enough information about an application key and its
      hosting platform to allow a Relying Party to make judicial
      decisions about the key, such as issuing a certificate.

   Platform:
      The module or device that embodies the Attester.  In this
      specification, it is interchangeable with "Attester" or "HSM".

   Platform Attestation:
      Evidence containing claims pertaining to an attesting platform.
      In general, the claims includes enough information about the
      platform to allow a Relying Party to make judicial decisions about
      the platform, such as audit reviews.

   Trust Anchor:
      As defined in [RFC6024] and [RFC9019], a Trust Anchor "represents
      an authoritative entity via a public key and associated data.  The
      public key is used to verify digital signatures, and the
      associated data is used to constrain the types of information for
      which the trust anchor is authoritative."  The Trust Anchor may be
      a certificate, a raw public key, or other structure, as
      appropriate.  It can be a non-root certificate when it is a
      certificate.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

4.  Architecture and Conceptual Model

   EDNOTE: JPF Note sure what in this section needs to be saved.

   Key attestation is an extension to the attestation functionality
   described in [RFC9334].  In the general RATS Architecture, an
   attesting device consists of a hardware Root of Trust (RoT) which
   provides the basis for trust in the device, and then one or more
   layers of attestations where an attesting environment collects and
   signs measurements (evidence) about a target environment.  Trust is
   established by chaining the cryptographic signatures on each layer of
   evidence up to the next layer of attester until the RoT is reached,
   and trust is established in the RoT via 3rd party endorsements.  The
   target devices for this specification tend to operate on a different
   architecture and trust model: the devices consist of one single
   logical environment (combining the RATS roles of RoT, attesting
   environment, and target environment together into a single entity),
   and trust is established via product validations conducted by third-
   party testing labs against standardized security and functional
   requirements such as FIPS 140-3 or a given Common Criteria protection
   profile.  A FIPS or CC certification provided by a testing lab would
   conceptually count as an endorsement of the hardware platform in the
   RATS architecture, but they are often not digitally-signed artifacts,
   and are often conveyed out of band, sometimes via a website or even
   via a paper certificate and so they are out of scope for the wire
   format specified in this document.

   As such, the attestation data format defined in this document does
   not capture the full functionality of the RATS architecture.  If a
   device producing evidence in the specified format requires to also
   carry nested attestation statements or endorsements, then it must be
   achieved by placing the attestation from this draft within another
   wrapper layer such as RATS Conceptual Message Wrapper (CMW)
   [I-D.ietf-rats-msg-wrap].

                      .-------------.
                      |             |
                      |  Verifier   |
                      |             |
                      '-------------'
                             |
                     PKIX    | Attestation
                     Evidence| Request
                             | (optional)
                             |   |
                             |   |
   .-------------------------|---+------.
   |                         |   |      |
   |    .----------------.   |   |      |
   |    | Target         |   |   |      |
   |    | Environment    |   |   |      |
   |    | (Platform &    |   |   |      |
   |    | Application    |   |   |      |
   |    | Keys)          |   |   |      |
   |    '--------------+-'   |   |      |
   |                   |     |   |      |
   |                   |     |   |      |
   |           Collect |     |   |      |
   |            Claims |     |   |      |
   |                   |     |   |      |
   |                   v     |   v      |
   |                 .-------+-----.    |
   |                 | Attesting   |    |
   |                 | Environment |    |
   |                 |             |    |
   |                 '-------------'    |
   |               Attester (HSM)       |
   '------------------------------------'

                           Figure 1: Architecture

   MikeO: While I understand that this image matches exactly the RATS
   architecture, I feel that we have lost something in that we no longer
   have the Attesting Environment collecting Claims about both the HSM
   itself and about application keys.  I would like to go back to the
   original diagram.

   Figure 1 depicts a typical workflow where an external tool queries
   the HSM for the status of one or more cryptographic keys that it is
   protecting ("Application Keys").  The "Presenter" may be, for
   example, a command-line or graphical user interface which will
   display the evidence to an operator or auditor; a cryptographic
   library which will include the evidence in a CSR for transmission to
   a Certification Authority; a TLS library which will include the
   evidence in at attested TLS session [I-D.fossati-tls-attestation]; or
   similar applications, refered to as the "Usage Protocol".

   This model does not assume any internal structure or logical
   separation within the HSM except for the existence of some kind of
   attestation service which may or may not be logically separate from
   the overall HSM Root of Trust, and that this attestation service
   measures the required evidence about both the hardware environment
   and the application keys that are being attested.  In addition to
   emitting key attestation evidence, an HSM may also need to parse it,
   for example when running in an operational mode that only allows
   importing keys from other HSMs at a comparable security level
   (requires checking for specific claims) or within the same
   operational network (requires checking the trust anchor of the
   attestation key certificate chain).  This implies that the
   attestation service needs to be part of the core HSM "kernel" and
   therefore would be subject to validations such as FIPS 140-3 or
   Common Criteria, which motivates a design requirement to keep the
   evidence data format as simple as possible and as close as possible
   to existing functionality and data models of existing HSM and TPM
   products.  As such, the information model presented in Section 6 will
   feel familiar to implementers with experience with PKI and PKCS#11.

4.1.  Attestation Key Certificate Chain

   The data format in this specification represents attestation evidence
   and requires third-party endorsement in order to establish trust.
   Part of this endorsement is a trust anchor that chains to the HSM's
   attestation key (AK) which signs the evidence.  In practice the trust
   anchor will usually be a manufacturing CA belonging to the device
   vendor which proves that the device is genuine and not counterfeit.
   The trust anchor can also belong to the device operator as would be
   the case when the AK certificate is replaced as part of onboarding
   the device into a new operational network.

   The AK certificate that signs the evidence MUST have the Extended Key
   Usage id-kp-attest defined in [TODO-submit-2-pager-to-lamps].

   Note that the data format specified in Section 6 allows for zero,
   one, or multiple 'SignatureBlock's, so a single evidence statement
   could be un-protected, or could be endorsed by multiple AK chains
   leading to different trust anchors.  See Section 8 for a discussion
   of handling multiple SignatureBlocks.

5.  Information Model

   The PKIX Evidence format is composed of two main sections:

   *  A claim description section which describes the information
      transmitted as Evidence.

   *  A signature section where one ore more digital signatures are
      offered to prove the origin of the claims and maintain their
      integrity.

   The details of the signature section is left to the data model.  The
   remainder of this section deals with the way the information is
   organized to form the claims.

   The claims are organized into a set of entities to help with the
   organization and comprehension of the information.  Entities are
   elements observed in the Target Environment by the Attester.  Each
   entity, in turn, is associated with a set of attributes.

   Therefore, the Claim description section is a set of entities and
   each entity is composed of a set of attributes.

5.1.  Entity

   An entity is composed of a type, the entity type, and a set of
   attributes.  The entity type describes the class of the entity while
   its attributes defines its state.

   An entity SHOULD be reported only once in a claim description.  The
   claim description can have multiple entities of the same type (for
   example reporting multiple keys), but each entity MUST be relating to
   different elements.  For example, if a given application public key
   appears in two different entities, these MUST be interpreted as two
   distinct and independent entities that happen to have the same public
   key, and MUST NOT be interpreted as adding attidional attributes to
   the already-described entity.  This restriction is to ease the
   implementation of Verifiers for the provided Evidence.

   The number of entities reported in a claim description, and their
   respective type, is left to the implementer.  For a simple device
   where there is only one key, the list of reported entities could be
   fixed.  For larger and more complex devices, the list of reported
   entities should be tailored to the demands of the requesting party.

   In particular, note that the nonce attribute contained with the
   Transaction entity is optional, and therefore it is possible that an
   extremely simple device that holds one static key could have its key
   attestation object generated at manufacture time and injected
   statically into the device and acting as a kind of certificate
   instead of being generated on-demand.  This model would essentially
   off-board the Attesting Environment to being part of the
   manufacturing infrastructure.

5.2.  Entity Type

   An entity is defined by its type.  This specification defines three
   entity types:

   *  Platform : This entity holds attributes relating to the state of
      the platform, or device, where the Attester is located.  Entities
      of this type holds attributes that are global in nature within the
      Target Environment.

   *  Key : The entities of this type represent a cryptographic key
      protected within the Target Environment and hold attributes
      relating to that key.

   *  Transaction : This is an entity logical in nature since it is
      associated with attributes that are not found in the Target
      Environment.  The attributes found in this entity relate to the
      current request for Evidence such as a nonce to support freshness.

   Although this document defines a short list of entity types, this
   list should be extensible to allow implementers to report on entities
   found in their implementation and not covered by this specification.
   By using an Object Identifier (OID) based system for identifying both
   entity types and the attribute types that they contain, this format
   is inherently extensible; implementers of Attesters MAY define new
   custom or proprietary entity types and place them along-side the
   standardized entities, or define new attribute types and place them
   inside standardized entities.

   Verifiers SHOULD ignore and skip over unrecognized entity or
   attribute types and continue processing normally.  In other words, if
   a given Evidence would have been acceptable without the unrecognized
   entity or attribute, then it SHOULD still be acceptable.  In PKI
   terminology, all custom entities and attributes not defined in this
   document SHOULD be considered non-critical unless a further
   specification indicates differently.

5.3.  Attribute and Attribute Type

   Each attribute found in an entity is composed of a type, the
   attribute type, and a value.  Each attribute describes a portion of
   the state of the associated entity.  For example, a platform entity
   could have an attribute which indicates the firmware version
   currently running.  Another example is a key entity with an attribute
   that reports whether the key is extractable or not.

   A value provided by an attribute is to be interpreted within the
   context of its entity and in relation to the attribute type.

   It is RECOMMENDED that an attribute type be defined for a specific
   entity type, to reduce confusion when it comes to interpretation of
   the value.  MikeO: I don't understand this sentence.  I think it
   needs better words.

   The nature of the value (boolean, integer, string, bytes) is
   dependent on the attribute type.

   This specification defines a limited number of attribute types.
   However, this list should be extensible to allow implementers to
   report attributes not covered by this specification.

   If a Verifier encounters an attribute with an unrecognized attribute
   type, it may ignore it.  In PKI terminology, all custom attributes
   not defined in this document SHOULD be considered non-critical unless
   a further specification indicates differently.

   The number of attributes reported within an entity, and their
   respective type, is left to the implementer.  For a simple device,
   the reported list of attributes for an entity might be fixed.
   However, larger and more complex devices, the list of reported
   attributes should be tailored to the demands of the requesting party.

   Some attributes MAY be repeated within an entity while others MUST
   NOT.  For example, for a platform entity, there can only be one
   "firmware version" attribute.  Therefore, the associated attribute
   MUST NOT be repeated as it may lead to confusion.  However, an
   attribute relating to a "loaded module" MAY be repeated, each
   attribute describing a different loaded module.  Therefore, the
   definition of an attribute specifies whether or not multiple copies
   of that attribute are allowed.

   If a Verifier encounters, within a single entity, multiple copies of
   an attribute specified as "Multiple Allowed: No", it MUST reject the
   evidence as mal-formed.

   If a Verifier encounters, within the context of an entity, a repeated
   attribute for a type where multiple attributes are allowed, it MUST
   treat each one as an independent attribute and MUST NOT consider
   later ones to overwrite or extend the previous one.

6.  Data Model

   This section describes the data model associated with PKIX Evidence.
   For ease of deployment within the target ecosystem, ASN.1 definitions
   and DER encoding are used.  A complete ASN.1 module is provided in
   Section 11.

   The top-level structures are:

   PkixEvidence ::= SEQUENCE {
       tbs ClaimDescriptionTbs,
       signatures SEQUENCE SIZE (0..MAX) of SignatureBlock
   }

   ClaimDescriptionTbs ::= SEQUENCE {
       version INTEGER,
       reportedEntities SEQUENCE SIZE (1..MAX) OF ReportedEntity
   }

   SignatureBlock ::= SEQUENCE {
      certChain SEQUENCE of Certificate,
      signatureAlgorithm AlgorithmIdentifier,
      signatureValue OCTET STRING
   }

   A PkixEvidence message is composed of a protected section known as
   the To-Be-Signed (TBS) where the claim description is reported.  The
   integrity of the TBS section is ensured with one or multiple
   cryptographic signatures over the content of the section.  There is a
   provision to carry the X.509 certificates supporting each signature.
   The SEQUENCE OF SignatureBlock allows for both multi-algorithm
   protection and for counter-signatures of the evidence.  In an effort
   to keep the evidence format simple, distinguishing between these two
   cases is left up to Verifier policy, potentially by making use of the
   certificates that accompany each signature.  Thes design also does
   not prevent against stripping attacks where an attacker removes a
   signature without leaving evidence in the message that an additional
   signature had been there or signature re-ordering attacks.  Again,
   this is left up to Verifier policy to know how many algorithms or
   counter-signatures it is expecting.  Consequently, Verifiers MUST NOT
   make any inferences about the lack of a signature.  For example,
   enumerating counter-signatures on an Evidence MUST NOT be considered
   to be a complete list of HSMs in a given cluster.  Similarly, the
   presense and order of counter-signatures MUST NOT be taken as proof
   of the path that the evidence traversed over the network.

   The TBS section is composed of a version number, to ensure future
   extensibility, and a sequence of reported entities.

   For compliance with this specification, ClaimDescriptionTbs.version
   MUST be 1.  This envelope format is not extensible; future
   specifications which make compatibility-breaking changes MUST
   increment the version number.

   EDNOTE: do we want extension marks on the TbsAttestation object?  I
   can see pros and cons to doing that.

   SignatureBlock.certChain MUST contain at least one X.509 certificate
   as per [RFC5280].  While there might exist attesting environments
   which use out-of-band or non-X.509 mechanisms for communicating the
   AK public key to the Verifier, these SHALL be considered non-
   compliant with this specification.

   As described in the Section 5 section, the claim description is a set
   of entities.  Each entity is associated with a type that defines its
   class.  The entity types are represented by object identifiers
   (OIDs).  The following ASN.1 definition defines the structures
   associated with entities:

   ReportedEntity ::= SEQUENCE {
       entityType         OBJECT IDENTIFIER,
       reportedAttributes SEQUENCE SIZE (1..MAX) OF ReportedAttribute
   }

   id-pkix-attest                    OBJECT IDENTIFIER ::= { 1 2 3 999 }
   id-pkix-attest-entity-type        OBJECT IDENTIFIER ::= { id-pkix-attest 0 }
   id-pkix-attest-entity-transaction OBJECT IDENTIFIER ::= { id-pkix-attest-entity-type 0 }
   id-pkix-attest-entity-platform    OBJECT IDENTIFIER ::= { id-pkix-attest-entity-type 1 }
   id-pkix-attest-entity-key         OBJECT IDENTIFIER ::= { id-pkix-attest-entity-type 2 }

   In turn, entities are composed of attributes.  Each attribute is
   composed of a type and a value.  The attribute types are represented
   by object identifiers (OIDs).  The following ASN.1 definition defines
   the structures associated with attributes:

   ReportedAttribute ::= SEQUENCE {
       attributeType      OBJECT IDENTIFIER,
       value              OPTIONAL AttributeValue
   }

   AttributeValue :== CHOICE {
      bytes       [0] IMPLICIT OCTET STRING
      utf8String  [1] IMPLICIT UTF8String,
      bool        [2] IMPLICIT BOOLEAN,
      time        [3] IMPLICIT GeneralizedTime,
      int         [4] IMPLICIT INTEGER,
      oid         [5] IMPLICIT OBJECT IDENTIFIER
   }

   The attributes associated with an entity are dependent on the type of
   entity.  Therefore, it is encouraged to define attribute types
   grouped with their respective entity type.

   The type of an attribute value is dictated by the attribute type.
   When an attribute type is defined, the definition must include the
   type of the value, its semantic and interpretation.

   The remainder of this section describes the entity types and their
   associated attributes.

6.1.  Platform Entity

   A platform entity is associated with the type identifier id-pkix-
   attest-entity-platform.  It is composed of a set of attributes that
   are global to the Target Environment.

   A platform entity, if provided, MUST be included only once within the
   reported entities.  If a Verifier encounters multiple entities of
   type id-pkix-attest-entity-platform, it MUST reject the Evidence as
   mal-formed.

   The following table lists the attributes for a platform entity
   (platform attributes) defined within this specification.  In cases
   where the attribute is borrowed from another specification, the
   "Reference" column refers to the specification where the semantics
   for the attribute value can be found.  Attributes defined in this
   specification have further details below.

   +=========+==============+===================+========+====================+
   |Attribute|AttributeValue|Reference          |Multiple|Description         |
   |         |              |                   |Allowed |                    |
   +=========+==============+===================+========+====================+
   |vendor   |utf8String    |RFCthis            |No      |A human-readable    |
   |         |              |                   |        |string by which the |
   |         |              |                   |        |vendor identifies   |
   |         |              |                   |        |themself.           |
   +---------+--------------+-------------------+--------+--------------------+
   |oemid    |bytes         |[I-D.ietf-rats-eat]|No      |The EAT OEM ID as   |
   |         |              |                   |        |defined in          |
   |         |              |                   |        |[I-D.ietf-rats-eat].|
   +---------+--------------+-------------------+--------+--------------------+
   |hwmodel  |utf8String    |[I-D.ietf-rats-eat]|No      |Model or product    |
   |         |              |                   |        |line of the hardware|
   |         |              |                   |        |module.             |
   +---------+--------------+-------------------+--------+--------------------+
   |hwserial |utf8String    |RFCthis            |No      |Serial number of the|
   |         |              |                   |        |hardware module,    |
   |         |              |                   |        |often matches the   |
   |         |              |                   |        |number engraved or  |
   |         |              |                   |        |stickered on the    |
   |         |              |                   |        |case.               |
   +---------+--------------+-------------------+--------+--------------------+
   |swversion|utf8String    |[I-D.ietf-rats-eat]|No      |A text string       |
   |         |              |                   |        |identifying the     |
   |         |              |                   |        |firmware or software|
   |         |              |                   |        |running on the HSM. |
   +---------+--------------+-------------------+--------+--------------------+
   |dbgstat  |int           |[I-D.ietf-rats-eat]|No      |Indicates whether   |
   |         |              |                   |        |the HSM is currently|
   |         |              |                   |        |in a debug state, or|
   |         |              |                   |        |is capable in the   |
   |         |              |                   |        |future of being     |
   |         |              |                   |        |turned to a debug   |
   |         |              |                   |        |state.  Semantics   |
   |         |              |                   |        |and integer codes   |
   |         |              |                   |        |are defined in      |
   |         |              |                   |        |[I-D.ietf-rats-eat].|
   +---------+--------------+-------------------+--------+--------------------+
   |uptime   |int           |[I-D.ietf-rats-eat]|No      |Contains the number |
   |         |              |                   |        |of seconds that have|
   |         |              |                   |        |elapsed since the   |
   |         |              |                   |        |entity was last     |
   |         |              |                   |        |booted.             |
   +---------+--------------+-------------------+--------+--------------------+
   |bootcount|int           |[I-D.ietf-rats-eat]|No      |Contains a count of |
   |         |              |                   |        |the number of times |
   |         |              |                   |        |the entity has been |
   |         |              |                   |        |booted.             |
   +---------+--------------+-------------------+--------+--------------------+
   |usermods |utf8String    |RFCthis            |Yes     |This attribute lists|
   |         |              |                   |        |user modules        |
   |         |              |                   |        |currently loaded    |
   |         |              |                   |        |onto the HSM in a   |
   |         |              |                   |        |human readable      |
   |         |              |                   |        |format.             |
   +---------+--------------+-------------------+--------+--------------------+
   |fipsboot |bool          |[FIPS.140-3]       |No      |Indicates whether   |
   |         |              |                   |        |the devices is      |
   |         |              |                   |        |currently running in|
   |         |              |                   |        |FIPS mode.          |
   +---------+--------------+-------------------+--------+--------------------+
   |fipsver  |utf8String    |[FIPS.140-3]       |No      |Indicates the       |
   |         |              |                   |        |version of the FIPS |
   |         |              |                   |        |CMVP standard that  |
   |         |              |                   |        |is being enforced.  |
   |         |              |                   |        |At time of writing  |
   |         |              |                   |        |this is typically   |
   |         |              |                   |        |"FIPS 140-2" or     |
   |         |              |                   |        |"FIPS 140-3".       |
   +---------+--------------+-------------------+--------+--------------------+
   |fipslevel|int           |[FIPS.140-3]       |No      |Indicates the FIPS  |
   |         |              |                   |        |Level to which the  |
   |         |              |                   |        |device is currently |
   |         |              |                   |        |operating in        |
   |         |              |                   |        |compliance with.    |
   +---------+--------------+-------------------+--------+--------------------+
   |envid    |utf8String    |RFCthis            |Yes     |An environment ID,  |
   |         |              |                   |        |which will typically|
   |         |              |                   |        |be a URI, UUID, or  |
   |         |              |                   |        |similar.            |
   +---------+--------------+-------------------+--------+--------------------+
   |envdesc  |utf8String    |RFCthis            |Yes     |Further description |
   |         |              |                   |        |of the environment. |
   +---------+--------------+-------------------+--------+--------------------+

                                  Table 1

   TODO: find the actual reference for "FIPS Mode" -- FIPS 140-3 does
   not define it (at least not the 11 page useless version of 140-3 that
   I found).

   Each attribute has an assigned OID, see Section 11.

6.1.1.  vendor

   A human-readable string that reports the name of the device's
   manufacturer.

6.1.2.  hwserial

   A human-readable string that reports the serial number of the
   hardware module.  This serial number often matches the number
   engraved on the case or on an applied sticker.

6.1.3.  usermods

   Most HSMs have some concept of trusted execution environment where
   user software modules can be loaded inside the HSM to run with some
   level of privileged access to the application keys.  This attribute
   lists user modules currently loaded onto the HSM in a human readable
   format, preferably JSON.

   EDNOTE: JPF if JSON, why have multiple attributes.

6.1.4.  fipsboot, fipsver and fipslevel

   FIPS 140-3 CMVP validation places stringent requirements on the mode
   of operation of the device and the cryptography offered by the
   module, including only enabling FIPS-approved algorithms, certain
   requirements on entropy sources, and extensive start-up self-tests.
   FIPS 140-3 offers compliance levels 1 through 4 with increasingly
   strict requirements.  Many HSMs include a configuration setting that
   allows the device to be taken out of FIPS mode and thus enable
   additional functionality or performance, and some offer configuration
   settings to change between compliance levels.

   The boolean attribute fipsboot indicates whether the device is
   currently operating in FIPS mode.  For most HSMs, changing this
   configuration setting from fipsboot=true to fips-boos=false is
   destructive and will result in zeroization of all cryptographic keys
   held within the module.

   The UTF8String attribute fipsver indicates the version of the FIPS
   CMVP specification with which the device's operational mode is
   compliant.  At the time of writing, the strings "FIPS 140-2" or "FIPS
   140-3" SHOULD be used.

   The integer attribute fipslevel indicates the compliance level to
   which the device is currently operating and MUST only be 1, 2, 3, or
   4.  The fipslevel attribute has no meaning if fipsboot is absent or
   false.

   The FIPS status information in PKIX Evidence indicates only the mode
   of operation of the device and is not authoritative of its validation
   status.  This information is available on the NIST CMVP website or by
   contacting the device vendor.  As an example, some devices may have
   the option to enable FIPS mode in configuration even if the vendor
   has not submitted this model for validation.  As another example, a
   device may be running in a mode consistent with FIPS Level 3 but the
   device was only validated and certified to Level 2.  A Relying Party
   wishing to know the validation status of the device MUST couple the
   device state information contained in the Evidence with a valid FIPS
   CMVP certificate for the device.

6.1.5.  envid

   An identifier for an environment to which the attested keys belong.
   These will be an a vendor-chosen format, but are constrained to ASCII
   as URIs, UUID, and similar types of identifiers are envisioned.

   There MAY be multiple envid attributes if the attested keys
   simultaneously belong to multiple environments.

   Note that by including envid as a platform attribute, this implies
   that it applies to all attested key entities.  If the HSM needs to
   attest multiple keys across multiple disjoint environments, then
   multiple PkixEvidences are required.  This naturally enforces privacy
   constraints of only attesting a single environment at a time.

   EDNOTE: JPF I do not understand this sub-section

   If an envdid request attribute contains a value, this means that the
   Presenter is requesting that only keys belogning to the given
   environment be included in the returned attestation.

6.1.6.  envdesc

   Further description of the environment beyond hwvendor, hwmodel,
   hwserial, swversion; for example if there is a need to describe
   multiple logical partitions within the same device.  Contents could
   be a human-readable description or other identifiers.

6.2.  Key Entity

   A key entity is associated with the type id-pkix-attest-entity-key.
   Each instance of a key entity represents a different cryptographic
   key found in the Target Environment.  There can be multiple key
   entities found in claim description, but each reported key entity
   MUST described a different cryptographic key.

   A key entity is composed of a set of attributes relating to the
   related cryptographic key.  At minimum, a key entity MUST have an
   attribute "identifier" to uniquely identify this cryptographic key
   from any others found in the same Target Environment.

   A Verifier that encounters a claim description with multiple key
   entities referring to the same cryptographic key MUST reject the
   Evidence.

   The following table lists the attributes for a key entity (key
   attributes) defined within this specification.  The "Reference"
   column refers to the specification where the semantics for the
   attribute value can be found.

   +===========+==============+=========+========+======================+
   |Attribute  |AttributeValue|Reference|Multiple|Description           |
   |           |              |         |Allowed |                      |
   +===========+==============+=========+========+======================+
   |identifier |utf8String    |RFCthis  |Yes     |Identifies the subject|
   |           |              |         |        |key, with a vendor-   |
   |           |              |         |        |specific format which |
   |           |              |         |        |could be numeric,     |
   |           |              |         |        |UUID, or other textual|
   |           |              |         |        |identifier.           |
   +-----------+--------------+---------+--------+----------------------+
   |spki       |bytes         |RFCthis  |No      |A complete DER-encoded|
   |           |              |         |        |SubjectPublicKeyInfo  |
   |           |              |         |        |representing the      |
   |           |              |         |        |public key associated |
   |           |              |         |        |with the asymetric key|
   |           |              |         |        |pair being attested.  |
   +-----------+--------------+---------+--------+----------------------+
   |purpose    |bytes         |[PKCS11] |No      |Defines the intended  |
   |           |              |         |        |usage for the key.    |
   +-----------+--------------+---------+--------+----------------------+
   |extractable|bool          |[PKCS11] |No      |Indicates if the key  |
   |           |              |         |        |is able to be exported|
   |           |              |         |        |from the module.      |
   |           |              |         |        |Corresponds directly  |
   |           |              |         |        |to PKCS#11            |
   |           |              |         |        |CKA_EXTRACTABLE.      |
   +-----------+--------------+---------+--------+----------------------+
   |sensitive  |bool          |[PKCS11] |No      |Indicates that the key|
   |           |              |         |        |cannot leave the      |
   |           |              |         |        |module in plaintext.  |
   |           |              |         |        |Corresponds directly  |
   |           |              |         |        |to PKCS#11            |
   |           |              |         |        |CKA_SENSITIVE.        |
   +-----------+--------------+---------+--------+----------------------+
   |never-     |bool          |[PKCS11] |No      |Indicates if the key  |
   |extractable|              |         |        |was able to be        |
   |           |              |         |        |exported from the     |
   |           |              |         |        |module.  Corresponds  |
   |           |              |         |        |directly to PKCS#11   |
   |           |              |         |        |CKA_NEVER_EXTRACTABLE.|
   +-----------+--------------+---------+--------+----------------------+
   |local      |bool          |RFCthis  |No      |Indicates whether the |
   |           |              |         |        |key was generated     |
   |           |              |         |        |locally or imported.  |
   +-----------+--------------+---------+--------+----------------------+
   |expiry     |time          |RFCthis  |No      |Defines the expiry    |
   |           |              |         |        |date or "not after"   |
   |           |              |         |        |time for the key.     |
   +-----------+--------------+---------+--------+----------------------+
   |protection |bytes         |RFCthis  |No      |Indicates any         |
   |           |              |         |        |additional key        |
   |           |              |         |        |protection properties.|
   +-----------+--------------+---------+--------+----------------------+

                                  Table 2

   PKCS#11 private key attributes can be somewhat complex to parse,
   especially as their exact meanings can vary by the key type and the
   exact details of key export mechanisms supported by the HSM.

   An attestation key might be visible to a client of the device and be
   reported along with other cryptographic keys.  Therefore, it is
   acceptable to include a key entity providing claims about an
   attestation key like any other cryptographic key.  An implemention
   MAY reject the generation of PKIX Evidence if it relates to an
   attestation key.

   EDNOTE: JPF I wonder if we should convert the table column
   "Description" to "OID" and provide the name of the OID.  It might be
   cleaner to provide the description in the associated sub-section.

   EDNOTE: JPF the next paragraph probably belongs somewhere else

   In most cases, the Verifier of a PKIX Attestation will want to know
   simply that the key is in hardware and cannot be extracted to be used
   with a software cryptographic module.  A setting of extractable=false
   satisfies this requirement.  Generally extractable=true &&
   sensitive=true also satisfies this requirement as the key cannot be
   extracted in plaintext, but only under key wrap.  This is common in
   HSM clustering scenarios, and is also common in scenarios where keys
   are exported under wrap so that they can be stored in an off-board
   database for re-import later, thus allowing the HSM to protect and
   manage a much larger set of keys than it has internal memory for.
   The never-extractable and local attributes give additional assurance
   that the key has always been in hardware and was not imported from
   software.

6.2.1.  identifier

   A human-readable string that uniquely identifies the cryptographic
   key.  This value often contains a UUID but could also have a numeric
   value expressed as text or any other textual description.

   This attribute MAY be repeated as some environments have more than
   one way to refer to a cryptographic key.

6.2.2.  spki

   The value of this attribute contains the DER-encoded field
   SubjectPublicKeyInfo (see [RFC5280]) associated with the
   cryptographic key.

6.2.3.  purpose

   TODO: probably need to define a mapping from PKCS#11 CKA enums to a
   bit-indexed byte array.

6.2.4.  local

   If provided and set, indicates that the cryptographic key was created
   by the device providing the Evidence.

6.2.5.  expiry

   Reports a time after which the key is not to be used.  The device MAY
   enforce this policy based on its internal clock.

6.2.6.  protection

   Indicates any additional key protection properties around use or
   modification of this key.  These are generalized properties and will
   not apply the same way to all HSM vendors.  Consult vendor
   documentation for the in-context meaning of these flags.

   TODO: define a bit-indexed byte array

   BIT MASK / Boolean Array {DualControl (0), CardControl (1),
   PasswordControl (2), ...}

   We may need to say that the first X are reserved for use by future
   RFCs that update this specification, and beyond that is private use.

6.3.  Transaction Entity

   A transaction entity is associated with the type id-pkix-attest-
   entity-transaction.  This is a logical entity and does not relate to
   an element found in the Target Environment.  Instead, it groups
   together attributes that relate to the request of generating the
   Evidence.

   For example, it is possible to include a "nonce" as part of the
   request to produce Evidence.  This nonce is repeated as part of the
   Evidence, within the portion protected for integrity, to prove the
   freshness of the claims.  This "nonce" is not related to any element
   in the Target Environment and the transaction entity is used to
   gather those values into attributes.

   A transaction entity, if provided, should be included only once
   within the reported entities.  If a Verifier encounters multiple
   entities of type id-pkix-attest-entity-transaction, it MUST reject
   the Evidence.

   The following table lists the attributes for a transaction entity
   (transaction attributes) defined within this specification.  The
   "Reference" column refers to the specification where the semantics
   for the attribute value can be found.

   A default and vendor-agnostic set of transaction attributes is
   defined in this section.

   These attribute types MAY be contained within a transaction entity;
   i.e. an entity identified by id-pkix-attest-entity-transaction.

    +=========+==============+===================+========+===========+
    |Attribute|AttributeValue|Reference          |Multiple|Description|
    |         |              |                   |Allowed |           |
    +=========+==============+===================+========+===========+
    |nonce    |bytes         |RFCthis            |No      |Repeats a  |
    |         |              |                   |        |"nonce"    |
    |         |              |                   |        |provided   |
    |         |              |                   |        |during the |
    |         |              |                   |        |request of |
    |         |              |                   |        |Evidence.  |
    +---------+--------------+-------------------+--------+-----------+
    |timestamp|time          |[I-D.ietf-rats-eat]|No      |The time at|
    |         |              |                   |        |which this |
    |         |              |                   |        |attestation|
    |         |              |                   |        |was        |
    |         |              |                   |        |generated. |
    |         |              |                   |        |Corresponds|
    |         |              |                   |        |to EAT IAT |
    |         |              |                   |        |claim.     |
    +---------+--------------+-------------------+--------+-----------+

                                  Table 3

6.3.1.  nonce

   The nonce attribute is used to provide "freshness" quality as to the
   claims provided in the PkixEvidence message.  A client requesting a
   PkixEvidence message MAY provide a nonce value as part of the
   request.  This nonce value, if provided, SHOULD be repeated as an
   attribute to the transaction entity.

6.3.2.  timestamp

   The time at which the PKIX Evidence was generated, according to the
   internal system clock of the Attester.

   EDNOTE: JPF Does this belong to Security Considerations?

   Note that it is common for HSMs to not have an accurate system clock;
   consider an HSM for a root CA kept offline and booted up infrequently
   in an local network segregated from all other network, or a smart
   card which boots up only when held against an NFC reader.
   Implementers of emitters SHOULD include this attribute only if the
   device reliably knows its own time (for example has had recent
   contact with an NTP server).  Implementers of parsers SHOULD be wary
   of trusting the contents of this attribute.  A challenge-response
   protocol that makes use of the nonce attribute is a far more reliable
   way of establishing freshness.

6.4.  Additional Entity and Attribute Types

   It is expected that HSM vendors will register additional Entity and
   Attribute types by assigning OIDs from their own proprietary OID arcs
   to hold data describing additional proprietary key properties.

   An Attester (HSM) which is requested to provide information about
   unrecognized Entity or Attribute types MUST fail the operation.

   A Verifier which encounters an unrecognized Entity or Attribute type
   MAY ignore it.

6.5.  Encoding

   A PkixEvidence is to be DER encoded [X.690].

   If a textual representation is required, then the DER encoding MAY be
   subsequently encoded into Base64.

   EDNOTE: I think we have to be precise about which flavour of Base64
   we are referrring to.

7.  Signing Procedure

   The SignatureBlock.signatureValue signs over the DER-encoded to-be-
   signed attestation data PkixEvidence.tbs and MUST be validated with
   the subject public key of the leaf X.509 certificate contained in the
   SignatureBlock.certChain.

8.  Verification Procedure

   The SignatureBlock.signatureValue signs over the DER-encoded to-be-
   signed attestation data PkixEvidence.tbs and MUST be validated with
   the subject public key of the leaf X.509 certificate contained in the
   SignatureBlock.certChain.

   Note that a PkixEvidence MAY contain zero or more SignatureBlocks.  A
   PkixEvidence with zero SignatureBlocks is unsigned, MUST be treated
   as un-protected and un-trusted, and any signature validation
   procedure MUST fail.

   More than one SignatureBlocks MAY be used to convey a number of
   different semantics.  For example, the HSM's Attesting Service might
   hold multiple Attestation Keys on different cryptographic algorithms
   in order to provide algorithm redundancy in the case that one
   algorithm becomes cryptographically broken.  In this case a Verifier
   would be expected to validate all SignatureBlocks.  Alternatively,
   the HSM's Attesting Service may hold multiple Attestion Keys (or
   multiple X.509 certificates for the same key) from multiple
   operational environments to which it belongs.  In this case a
   Verifier would be expected to only validate the SignatureBlock
   corresponding to its own environment.  Alternatively, multiple
   SignatureBlocks could be used to convey counter-signatures from
   external parties, in which case the Verifier will need to be equipped
   with environment-specific verification logic.  Multiple of these
   cases, and potentially others, could be present in a single
   PkixEvidence object.

   Note that each SignatureBlock is a fully detached signature over the
   tbs content with no binding between the signed content and the
   SignatureBlocks, or between SignatureBlocks, meaning that a third
   party can add a counter-signature of the evidence after the fact, or
   an attacker can remove a SignatureBlock without leaving any artifact.
   See {#sec-detached-sigs} for further discussion.

9.  Attestation Requests

   EDNOTE: MikeO: this is complex, but I'm not really sure how to define
   a request format in any simpler way.  Ideas are welcome!

   This section specifies a standardized format that a Presenter can use
   to request a PKIX Attestation about a specific key or set of keys, a
   specific environment, or containing specific attributes.

   Hardware Security Modules range greatly in size and complexity from
   personal cryptographic tokens containing a single application key
   such as a smartcard acting as a personal ID card, up to clusters of
   enterprise-grade HSMs serving an entire cloud service.

   The manufacturer of a HSM device with limited capabilities may
   implement a response to the attestation request which includes a
   fixed set of reported entities, each with a fixed set of reported
   attributes and parses an Attestion Request object only for the
   purposes of extracting the nonce.

   On the other hand, an enterprise grade HSM with the capability to
   hold a large number of private keys is expected to be capable of
   parsing attestation requests such that a Presenter can request
   attestation of specific key(s) by their identifier, or request
   attestation of all keys with given key attributes within a given sub-
   environment of the HSM.  A full implementation will also create a
   PKIX Attestation containing exactly the set of requested attributes
   so that the Presenter can fine-tune the information that it wishes to
   disclose to the Recipient.

   A PKIX Attestation Request consists of a un-signed
   ClaimDescriptionTbs object containing a single ReportedEntity
   identified with id-pkix-attest-entity-request, called a request
   entity.  A ClaimDescriptionTbs containing a request entity MUST NOT
   contain any other type of entities.  Request entities MAY contain
   Attributes of any type; transaction, platform, key, or any additional
   attribute type.  Any attribute contained in a request entity is
   called a request attribute.  Request entities MUST NOT appear in PKIX
   Attestation response objects.  The ClaimDescriptionTbs object of an
   attestation request MAY appear inside a signed PkixEvidence for the
   purposes of authenticating and authorizing the requester, but the
   semantics of doing so are left to the implementer.

   An Attester that supports Attestation Requests MUST, at the minimum,
   support extracting the value from a nonce attribute and echoing it
   into a nonce attribute within a TransactionEntity.

   Some request attributes contain a value that the HSM uses as a filter
   or search parameter in constructing the PKIX Attestation; these are
   called valued requests attributes.  Other requests attributes omit
   the optional value field so that they consist of only the attribute
   type OID and indicate that the HSM SHOULD collect and return the
   appropriate measurement; these are called un-valued request
   attributes.  An Attester SHOULD return a PKIX Attestation containing
   exactly the set of attributes listed in the request, including both
   valued and un-valued request attributes but MAY omit requested
   attributes if it cannot be measured in the current device
   configuration.  Note that an Attestation Request will contain all
   request attributes inside a single request entity, but the HSM MUST
   sort the attributes in the response PKIX Attestation into the
   appropriate entity types.  For example, if the request contains the
   key purpose attribute (either valued or un-valued), then all returned
   key entities will contain the purpose attribute when this data is
   available for the given key.  The tables in the following sections
   indicate whether an attribute of the given type MUST, MAY, or MUST
   NOT contain a value when included in a request entity.

   Generally errors should be handled gracefully by simply omitting an
   unfulfillable request attribute from the response.  An example would
   be if the hwserial attribute was requested but the devices does not
   have a serial number.  However in some cases a fatal error MAY be
   returned, for example if attestation of a specific key is requested
   by key identifier or SubjectPublicKeyInfo but the HSM does not
   contain a matching key.  HSMs SHOULD ignore request attributes with
   unrecognized type OIDs.

   Generally, the Attester SHOULD NOT include additional attributes
   beyond those that were requested.  This is to allow the Presenter to
   fine-tune the information that will be disclosed to the Recipient.
   Further privacy concerns are discussed in Section 13.3.  However, in
   some contexts this MAY be appropriate, for example, a request
   containing only a key identifier attribute could be responded to with
   the full set of platform and key attributes that apply to that key.
   Discretion is left to implementers.

   For both error handling and privacy reasons, the Presenter SHOULD
   check that the returned PKIX Attestation contains the expected
   attributes prior to forwarding it to the Recipient.

10.  Appraisal Policies and Profiles

   This section provides some sample profiles of appraisal policies that
   verifiers MAY apply when evaluating evidence.  These appraisal
   profiles represent environment-specific requirements on the contents
   of the evidence and / or endorsement certificate chain.

10.1.  Key Import into an HSM

   An HSM which is compliant with this draft SHOULD validate any PKIX
   Key Attestations that are provided along with the key being imported.

   The SignatureBlocks MUST be validated and MUST chain to a trust
   anchor known to the HSM.  In most cases this will be the same trust
   anchor that endorsed the HSMs own AK, but the HSM MAY be configured
   with set of third party trust anchors from which it will accept key
   attestations.

   If the HSM is operating in FIPS Mode, then it MUST only import keys
   from HSMs also operating in FIPS Mode.

   The claims key-purpose, key-extractable, key-never-extractable, key-
   local MUST be checked and honoured during key import, which typically
   means that after import, the key MUST NOT claim a stronger protection
   property than it had on the previous hardware.  In other words, Key
   Attestation allows and requires that key protection properties be
   preserved over export / import operations between different HSMs, and
   this format provides a vendor-agnostic way to acheive this.

   How to handle errors is outside the scope of this specification and
   is left to implementors; for example the key import MAY be aborted,
   or a prompt MAY be given to the user administrator, or any similar
   reasonable error handling logic.

10.2.  CA/Browser Forum Code-Signing

   TODO: ... intro text

   The subscriber MUST:

   *  Provide the CA with a CSR containing the subscriber key.

   *  Provide an attestation token as per this specification describing
      the private key protection properties of the subscriber's private
      key.  This token MAY be transported inside the CSR as per draft-
      ietf-lamps-csr-attest, or it MAY be transported adjacent to the
      CSR over any other certificate enrollment mechanism.

   The CA / RA / RP / Verifier MUST:

   *  Ensure that the subscriber key which is the subject of the CSR is
      also described by a KAT by matching either the key fingerprint or
      full SubjectPublicKeyInfo.

   *  The hardware root-of-trust described by a PAT has a valid and
      active FIPS certificate according to the NIST CMVP database.

   *  The attestation signing key (AK) which has signed the attestation
      token chains to a root certificate that A) belongs to the hardware
      vendor described in the PAT token, and B) is trusted by the CA /
      RA / RP / Verifier to endorse hardware from this vendor, for
      example through a CA's partner program or through a network
      operator's device on-boarding process.

   *  The key is protected by a module running in FIPS mode.  The
      parsing logic is to start at the leaf KAT token that matches the
      key in the CSR and parsing towards the root PAT ensuring that
      there is at least one fipsboot=true and no fipsboot=false on that
      path.

11.  ASN.1 Module

   <CODE STARTS>

   PKIX-Evidence-2025
       { iso(1) identified-organization(3) dod(6) internet(1)
       security(5) mechanisms(5) pkix(7) id-mod(0)
       id-mod-pkix-evidence-2025(99) }

   DEFINITIONS IMPLICIT TAGS ::=
   BEGIN

   PkixEvidence ::= SEQUENCE {
       tbs TbsPkixEvidence,
       signatures SEQUENCE SIZE (0..MAX) OF SignatureBlock
   }

   TbsPkixEvidence ::= SEQUENCE {
       version INTEGER,
       reportedEntities SEQUENCE SIZE (1..MAX) OF ReportedEntity
   }

   ReportedEntity ::= SEQUENCE {
       entityType         OBJECT IDENTIFIER,
       reportedAttributes SEQUENCE SIZE (1..MAX) OF ReportedAttribute
   }

   ReportedAttribute ::= SEQUENCE {
       attributeType      OBJECT IDENTIFIER,
       value              AttributeValue
   }

   AttributeValue ::= CHOICE {
      bytes       [0] OCTET STRING
      utf8String  [1] UTF8String,
      bool        [2] BOOLEAN,
      time        [3] GeneralizedTime,
      int         [4] INTEGER,
      oid         [5] OBJECT IDENTIFIER
   }

   SignatureBlock ::= SEQUENCE {
      certChain SEQUENCE OF Certificate,
      signatureAlgorithm AlgorithmIdentifier,
      signatureValue OCTET STRING
   }

   id-pkix-evidence OBJECT IDENTIFIER ::= { 1 2 3 999 }

   id-pkix-evidence-entity-type        OBJECT IDENTIFIER ::= { id-pkix-evidence- 0 }
   id-pkix-evidence-entity-transaction OBJECT IDENTIFIER ::= { id-pkix-evidence-entity-type 0 }
   id-pkix-evidence-entity-platform    OBJECT IDENTIFIER ::= { id-pkix-evidence-entity-type 1 }
   id-pkix-evidence-entity-key         OBJECT IDENTIFIER ::= { id-pkix-evidence-entity-type 2 }

   id-pkix-evidence-attribute-type OBJECT IDENTIFIER ::= { id-pkix-evidence- 1 }

   id-pkix-evidence-attribute-transaction       OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-type 0 }
   id-pkix-evidence-attribute-transaction-nonce OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-transaction 0 }

   id-pkix-evidence-attribute-platform            OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-type 1 }
   id-pkix-evidence-attribute-platform-vendor     OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 0 }
   id-pkix-evidence-attribute-platform-hwserial   OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 1 }
   id-pkix-evidence-attribute-platform-fipsboot   OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 2 }
   id-pkix-evidence-attribute-platform-desc       OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 3 }
   id-pkix-evidence-attribute-platform-time       OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 4 }
   id-pkix-evidence-attribute-platform-swversion  OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 5 }
   id-pkix-evidence-attribute-platform-oemid      OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 6 }
   id-pkix-evidence-attribute-platform-debugstat  OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 7 }
   id-pkix-evidence-attribute-platform-uptime     OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 8 }
   id-pkix-evidence-attribute-platform-bootcount  OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 9 }
   id-pkix-evidence-attribute-platform-usermods   OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 8 }
   id-pkix-evidence-attribute-platform-envid      OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 9 }
   id-pkix-evidence-attribute-platform-envdesc    OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 10 }
   id-pkix-evidence-attribute-platform-fipsver    OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 11 }
   id-pkix-evidence-attribute-platform-fipslevel  OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-platform 12 }



   id-pkix-evidence-attribute-key                   OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-type 2 }
   id-pkix-evidence-attribute-key-identifier        OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 0 }
   id-pkix-evidence-attribute-key-spki              OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 1 }
   id-pkix-evidence-attribute-key-purpose           OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 2 }
   id-pkix-evidence-attribute-key-extractable       OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 3 }
   id-pkix-evidence-attribute-key-never-extractable OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 4 }
   id-pkix-evidence-attribute-key-local             OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 5 }
   id-pkix-evidence-attribute-key-expiry            OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 6 }
   id-pkix-evidence-attribute-key-protection        OBJECT IDENTIFIER ::= { id-pkix-evidence-attribute-key 7 }

   <CODE ENDS>

12.  IANA Considerations

   Please replace "RFCthis" with the RFC number assigned to this
   document.

   TODO: list out all the OIDs that need IANA registration.

13.  Security Considerations

   A Verifier MAY reject a PKIX Attestation if it lacks required
   attributes per their appraisal policy.  For example, if a Relying
   Party mandates a FIPS-certified device, it SHOULD reject evidence
   lacking sufficient information to verify the device's FIPS
   certification status.

13.1.  Simple to Implement

   The nature of attestation requires the attestation service to be
   implemented in an extremely privileged position within the HSM so
   that it can collect measurements of both the hardware environment and
   the application keys being attested.  For many HSM and TPM
   architectures, this will place the Attestation Service inside the
   "HSM kernel" and potentially subject to FIPS 140-3 or Common Criteria
   validation and change control.  For both security and compliance
   reasons there is incentive for the emitting and parsing logic to be
   simple and easy to implement correctly.  Additionally, when the data
   formats contained in this specification are parsed within an HSM
   boundary -- that would be parsing a request entity, or parsing an
   attestation produced by a different HSM -- implementers SHOULD opt
   for simple logic that rejects any data that does not match the
   expected format instead of attempting to be flexible.

   In particular, Attesting Services SHOULD generate the attestation
   object from scratch and avoid copying any content from the request.
   Attesting Services MUST NOT allow unrecognized attributes or any
   attribute value other than the nonce to be echoed from the request
   into the attestation object.

13.2.  Detached Signatures

   TODO beef this up

   No indication within the tbs content about what or how many
   signatures to expect.

   A SignatureBlock can be trivially stripped off without leaving any
   evidence.

   When multiple SignatureBlocks are used for providing third party
   counter-signatures, note that the counter signature only covers the
   tbs content and not existing SignatureBlocks.

13.3.  Privacy

   Often, a TPM will host cryptographic keys for both the kernel and
   userspace of a local operating system but a Presenter may only
   represents a single user or application.  Similarly, a single
   enterprise-grade Hardware Security Module will often host
   cryptographic keys for an entire multi-tenant cloud service and the
   Presenter or Reciever or Recipient belongs only to a single tenant.
   For example the HSM backing a TLS-terminating loadbalancer fronting
   thousands of un-related web domains.  In these cases, disclosing that
   two different keys reside on the same hardware, or in some cases even
   disclosing the existance of a given key, let alone its attributes, to
   an unauthorized party would constitute an egregious privacy
   violation.

   Implementions SHOULD be careful to avoid over-disclosure of
   information, for example by authenticating the Presenter as described
   in Section 13.4 and only returning results for keys and envirnments
   for which it is authorized.  In absence of an existing mechanism for
   authenticating and authorizing administrative connections to the HSM,
   the attestation request MAY be authenticated by embedding the
   ClaimDescriptionTbs of the request inside a PkixEvidence signed with
   a certificate belogning to the Presenter.

   Furthermore, enterprise and cloud-services grade HSMs SHOULD support
   the full set of attestation request functionality described in
   Section 9 so that Presenters can fine-tune the content of a PKIX
   Attestation such that it is appropriate for the intended Recipient.

13.4.  Authenticating and Authorizing the Presenter

   The Presenter represents a priviledged role within the architecture
   of this specification as it gets to learn about the existence of
   application keys and their protection properties, as well as details
   of the platform.  The Presenter is in the position of deciding how
   much information to disclose to the Recipient, and to request a
   suitably redacted attestation from the HSM.

   For personal cryptographic tokens it might be appropriate for the
   attestation request interface to be un-authenticated.  However, for
   enterprise and cloud-services grade HSMs the Presenter SHOULD be
   authenticated using the HSM's native authentication mechanism.  The
   details will be HSM-specific and are thus left up to the implementer,
   however it is RECOMMENDED to implement an authorization framework
   similar to the following.

   A Presenter SHOULD be allowed to request attestation for any
   application keys which it is allowed to use.  For example, a TLS
   application that is correctly authenticated to the HSM in order to
   use its TLS keys SHOULD be able to request attestation of those same
   keys without needing to perform any additional authentication or
   requiring any additional roles or permissions.  HSMs that wish to
   allow a Presenter to request attestation of keys which is not allowed
   to use, for example for the purposes of displaying HSM status
   information on an administrative console or UI, SHOULD have a
   "Attestation Requester" role or permission and SHOULD enforce the
   HSM's native access controls such that the Presenter can only
   retrieve attestations for keys for which it has read access.

13.5.  Proof-of-Possession of Application Keys

   With asymmetric keys within a Public Key Infrastructure (PKI) it is
   common to require a key holder to prove that they are in control of
   the private key by using it.  This is called "proof-of-possession
   (PoP)".  This specification intentionally does not provide a
   mechnaism for PoP of application keys and relies on the Presenter,
   Recipient, Verifier, and Relying Party trusting the Attester to
   correctly report the cryptographic keys that it is holding.

   It would be easy to add a PoP Key Attribute that uses the attested
   application key to sign over, for example, the Transaction Entity,
   however this is a bad idea and MUST NOT be added as a custom
   attribute for several reasons.

   First, an application key intended, for example, for TLS SHOULD only
   be used with the TLS protocol and introducing a signature oracle
   whereby the TLS application key is used to sign attestation content
   could lead to cross-protocol attacks whereby the attacker submits a
   nonce value which is in fact not random but is crafted in such a way
   as to appear as a valid message in some other protocol context or
   exploit some other weakness in the signature algorithm.

   Second, the Presenter who has connected to the HSM to request an
   attestation may have permissions to view the requested application
   keys but not permission to use them, as in the case where the
   Presenter is an administrative UI displaying HSM status information
   to an systems administrator or auditor.  Requiring the Attestation
   Service to use the attested application keys could, in some
   architectures, require the Attestation Service to resolve complex
   access control logic and handle complex error conditions for each
   requested key, which violates the "simple to implement" design
   principle outlined in Section 13.1.  More discussion of
   authenticating the Presenter can be found in Section 13.4.

   In cases where explicit PoP is required for a given attested
   application key, it MUST be done as part of the regular usage
   protocol for which that key is intended and performed through the
   HSM's regular application interface, not its attestation interface.
   For example, PoP could be performed by signing a Certificate Signing
   Request (CSR), through a PKI enrollment protocol such as Certificate
   Management Protocol (CMP) which includes a challenge-response PoP, by
   using the key within a TLS handshake, or some other protocol which is
   part of the key's intended usage.

14.  References

14.1.  Normative References

   [FIPS.140-3]
              NIST - Information Technology Laboratory, "SECURITY
              REQUIREMENTS FOR CRYPTOGRAPHIC MODULES", FIPS 140-3, n.d.,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.140-3.pdf>.

   [I-D.ietf-rats-eat]
              Lundblade, L., Mandyam, G., O'Donoghue, J., and C.
              Wallace, "The Entity Attestation Token (EAT)", Work in
              Progress, Internet-Draft, draft-ietf-rats-eat-31, 6
              September 2024, <https://datatracker.ietf.org/doc/html/
              draft-ietf-rats-eat-31>.

   [PKCS11]   Cox, D. B. T., "PKCS #11 Specification Version 3.1", n.d.,
              <https://docs.oasis-open.org/pkcs11/pkcs11-spec/v3.1/cs01/
              pkcs11-spec-v3.1-cs01.html>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/rfc/rfc5280>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9334]  Birkholz, H., Thaler, D., Richardson, M., Smith, N., and
              W. Pan, "Remote ATtestation procedureS (RATS)
              Architecture", RFC 9334, DOI 10.17487/RFC9334, January
              2023, <https://www.rfc-editor.org/rfc/rfc9334>.

   [X.680]    ITU-T, "Information technology -- Abstract Syntax Notation
              One (ASN.1): Specification of basic notation", n.d.,
              <https://www.itu.int/rec/T-REC-X.680>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.

14.2.  Informative References

   [CNSA2.0]  "Commercial National Security Algorithm Suite 2.0", n.d.,
              <https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/
              CSA_CNSA_2.0_ALGORITHMS_.PDF>.

   [codesigningbrsv3.8]
              "Baseline Requirements for the Issuance and Management of
              PubliclyTrusted Code Signing Certificates Version 3.8.0",
              n.d., <https://cabforum.org/working-groups/code-signing/
              documents/>.

   [I-D.fossati-tls-attestation]
              Tschofenig, H., Sheffer, Y., Howard, P., Mihalcea, I.,
              Deshpande, Y., Niemi, A., and T. Fossati, "Using
              Attestation in Transport Layer Security (TLS) and Datagram
              Transport Layer Security (DTLS)", Work in Progress,
              Internet-Draft, draft-fossati-tls-attestation-09, 30 April
              2025, <https://datatracker.ietf.org/doc/html/draft-
              fossati-tls-attestation-09>.

   [I-D.ietf-lamps-csr-attestation]
              Ounsworth, M., Tschofenig, H., Birkholz, H., Wiseman, M.,
              and N. Smith, "Use of Remote Attestation with
              Certification Signing Requests", Work in Progress,
              Internet-Draft, draft-ietf-lamps-csr-attestation-21, 5
              October 2025, <https://datatracker.ietf.org/doc/html/
              draft-ietf-lamps-csr-attestation-21>.

   [I-D.ietf-rats-msg-wrap]
              Birkholz, H., Smith, N., Fossati, T., Tschofenig, H., and
              D. Glaze, "RATS Conceptual Messages Wrapper (CMW)", Work
              in Progress, Internet-Draft, draft-ietf-rats-msg-wrap-18,
              29 September 2025, <https://datatracker.ietf.org/doc/html/
              draft-ietf-rats-msg-wrap-18>.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS #10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              DOI 10.17487/RFC2986, November 2000,
              <https://www.rfc-editor.org/rfc/rfc2986>.

   [RFC4211]  Schaad, J., "Internet X.509 Public Key Infrastructure
              Certificate Request Message Format (CRMF)", RFC 4211,
              DOI 10.17487/RFC4211, September 2005,
              <https://www.rfc-editor.org/rfc/rfc4211>.

   [RFC6024]  Reddy, R. and C. Wallace, "Trust Anchor Management
              Requirements", RFC 6024, DOI 10.17487/RFC6024, October
              2010, <https://www.rfc-editor.org/rfc/rfc6024>.

   [RFC9019]  Moran, B., Tschofenig, H., Brown, D., and M. Meriac, "A
              Firmware Update Architecture for Internet of Things",
              RFC 9019, DOI 10.17487/RFC9019, April 2021,
              <https://www.rfc-editor.org/rfc/rfc9019>.

Appendix A.  Samples

   A reference implementation of this specification can be found at
   https://github.com/hannestschofenig/keyattestation

   It produces the following sample attestation:

PkixAttestation:
 tbs=TbsPkixAttestation:
  version=2
  reportedEntities=SequenceOf:
   ReportedEntity:
    entityType=1.2.3.999.0.0
    reportedAttributes=SequenceOf:
     ReportedAttribute:
      attributeType=1.2.3.999.1.0.0
      value=AttributeValue:
       bytes=0102030405


   ReportedEntity:
    entityType=1.2.3.999.0.1
    reportedAttributes=SequenceOf:
     ReportedAttribute:
      attributeType=1.2.3.999.1.1.0
      value=AttributeValue:
       utf8String=HSM-123

     ReportedAttribute:
      attributeType=1.2.3.999.1.1.1
      value=AttributeValue:
       bool=True

     ReportedAttribute:
      attributeType=1.2.3.999.1.1.2
      value=AttributeValue:
       utf8String=Model ABC

     ReportedAttribute:
      attributeType=1.2.3.999.1.1.4
      value=AttributeValue:
       utf8String=3.1.9

     ReportedAttribute:
      attributeType=1.2.3.999.1.1.3
      value=AttributeValue:
       time=202502032234Z


   ReportedEntity:
    entityType=1.2.3.999.0.2
    reportedAttributes=SequenceOf:
     ReportedAttribute:
      attributeType=1.2.3.999.1.2.0
      value=AttributeValue:
       utf8String=26d765d8-1afd-4dfb-a290-cf867ddecfa1

     ReportedAttribute:
      attributeType=1.2.3.999.1.2.3
      value=AttributeValue:
       bool=False

     ReportedAttribute:
      attributeType=1.2.3.999.1.2.1
      value=AttributeValue:
       bytes=0x3059301306072a8648ce3d020106082a8648ce3d03010703420004422548f88fb782ffb5eca3744452c72a1e558fbd6f73be5e48e93232cc45c5b16c4cd10c4cb8d5b8a17139e94882c8992572993425f41419ab7e90a42a494272


   ReportedEntity:
    entityType=1.2.3.999.0.2
    reportedAttributes=SequenceOf:
     ReportedAttribute:
      attributeType=1.2.3.999.1.2.0
      value=AttributeValue:
       utf8String=49a96ace-e39a-4fd2-bec1-13165a99621c

     ReportedAttribute:
      attributeType=1.2.3.999.1.2.3
      value=AttributeValue:
       bool=True

     ReportedAttribute:
      attributeType=1.2.3.999.1.2.1
      value=AttributeValue:
       bytes=0x3059301306072a8648ce3d020106082a8648ce3d03010703420004422548f88fb782ffb5eca3744452c72a1e558fbd6f73be5e48e93232cc45c5b16c4cd10c4cb8d5b8a17139e94882c8992572993425f41419ab7e90a42a494272


   ReportedEntity:
    entityType=1.2.3.888.0
    reportedAttributes=SequenceOf:
     ReportedAttribute:
      attributeType=1.2.3.888.1
      value=AttributeValue:
       utf8String=partition 1




 signatures=SequenceOf:
  SignatureBlock:
   certChain=SequenceOf:
    Certificate:
     tbsCertificate=TBSCertificate:
      version=v3
      serialNumber=510501933685942792810365453374472870755160518925
      signature=AlgorithmIdentifier:
       algorithm=1.2.840.113549.1.1.11
       parameters=0x0500

      issuer=Name:
       rdnSequence=RDNSequence:
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.10
          value=0x0c0449455446
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.11
          value=0x0c0452415453
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.3
          value=0x0c06414b20525341


      validity=Validity:
       notBefore=Time:
        utcTime=250117171303Z

       notAfter=Time:
        generalTime=20520604171303Z


      subject=Name:
       rdnSequence=RDNSequence:
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.10
          value=0x0c0449455446
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.11
          value=0x0c0452415453
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.3
          value=0x0c06414b20525341


      subjectPublicKeyInfo=SubjectPublicKeyInfo:
       algorithm=AlgorithmIdentifier:
        algorithm=1.2.840.113549.1.1.1
        parameters=0x0500

       subjectPublicKey=31795268810366627125468059984427145931784542919710733587190808152893606542214208096328883077225607136393362795609997601968312039001251339428349101203532726047646450301142882318337709398316574407647199690000689245113739552615279534528145776090813314822312012607567736073057936820713733090928849092672110937300300755561797808000438134839458043673852453722969649609202093945235393494912138691342219564365300965387743701570507112064401758218314760153081271981340812350365663466513620853326534252424706992841033652817461354632316129312597825542820569667842318342646457447037125609399476844336456206583416539426479221164971369788464727307915820767918489601

      extensions=Extensions:
       Extension:
        extnID=2.5.29.14
        critical=False
        extnValue=0x04148919595e0ef169f5cbbd47e134fce298cc693091
       Extension:
        extnID=2.5.29.35
        critical=False
        extnValue=0x301680148919595e0ef169f5cbbd47e134fce298cc693091
       Extension:
        extnID=2.5.29.19
        critical=True
        extnValue=0x30030101ff


     signatureAlgorithm=AlgorithmIdentifier:
      algorithm=1.2.840.113549.1.1.11
      parameters=0x0500

     signature=12977775424631768289542539102653382982431795551146145281750189553757940982572813264428982985997740595878077027853994515775116752030963858469651548765808775269857271167748512795017916284867051302884465315751010913658016640170608413935780119349866986170148033301955753116984041271273907756544780231564646860424999020990745523383622980115200446260103173103500647838758197610238552349053064525420240826193553395378873725256584269666918504793674497748455574822238022085054752185687440807655337724821853332688158460379554906105417720665175648371832825939577039874730442790337726004105878168375998123110331993348833629325492

   signatureAlgorithm=AlgorithmIdentifier:
    algorithm=1.2.840.113549.1.1.10
    parameters=RSASSA_PSS_params:
     hashAlgorithm=AlgorithmIdentifier:
      algorithm=2.16.840.1.101.3.4.2.1

     maskGenAlgorithm=AlgorithmIdentifier:
      algorithm=1.2.840.113549.1.1.8

     saltLength=20
     trailerField=1


   signatureValue=0x9b6ac1932f1cd85befbde054e084577ebc9181bcf05179658a700e22556fc3f1931f59dc9734efe08df204fcfe55c64c6a97e8d520e58c1f64080b6cce1c08e88db510c06d6914a818b70df82326b37a2abe54fab0567d748e1e82e2de954cac63c5ab3bc92fff9cb8aa64fbcb83dd8bacbce96392f91dd40ee05058adceb11f5cf0c379241fd470918abceea70fd01c0cbc64d96067fe549ec443738655bc2bcf7e5bd54c15d5e5ac2f4ad180d973a7e6025126ccd2b45d78e9944662237959ef73f47e9ae0fa9b0c55177bb6f867a90b41d0efb72c192f15a66531d030bc85fed3d135aea4045e024ef2e807517504d313dbea4b0f709d0553b60793b2dcaa
  SignatureBlock:
   certChain=SequenceOf:
    Certificate:
     tbsCertificate=TBSCertificate:
      version=v3
      serialNumber=43752118382009037811618748949928339462896457144
      signature=AlgorithmIdentifier:
       algorithm=1.2.840.10045.4.3.2

      issuer=Name:
       rdnSequence=RDNSequence:
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.10
          value=0x0c0449455446
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.11
          value=0x0c0452415453
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.3
          value=0x0c07414b2050323536


      validity=Validity:
       notBefore=Time:
        utcTime=250117171428Z

       notAfter=Time:
        generalTime=20520604171428Z


      subject=Name:
       rdnSequence=RDNSequence:
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.10
          value=0x0c0449455446
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.11
          value=0x0c0452415453
        RelativeDistinguishedName:
         AttributeTypeAndValue:
          type=2.5.4.3
          value=0x0c07414b2050323536


      subjectPublicKeyInfo=SubjectPublicKeyInfo:
       algorithm=AlgorithmIdentifier:
        algorithm=1.2.840.10045.2.1
        parameters=0x06082a8648ce3d030107

       subjectPublicKey=57095560233504924588952816185508037812996307929249104847846164660564888397123390877585670462836285725041261897550020311481127562655774333675293173915140722

      extensions=Extensions:
       Extension:
        extnID=2.5.29.14
        critical=False
        extnValue=0x04145b70a79817f79ff637d2f7e3dc446c2109d7bbd4
       Extension:
        extnID=2.5.29.35
        critical=False
        extnValue=0x301680145b70a79817f79ff637d2f7e3dc446c2109d7bbd4
       Extension:
        extnID=2.5.29.19
        critical=True
        extnValue=0x30030101ff


     signatureAlgorithm=AlgorithmIdentifier:
      algorithm=1.2.840.10045.4.3.2

     signature=182167519797146035745575043154801415115532979136731128676399180692664821804883990401552040789643013103202424486088058364982966709324496782518079519267269438816178719668437

   signatureAlgorithm=AlgorithmIdentifier:
    algorithm=1.2.840.10045.2.1
    parameters=0x06082a8648ce3d030107

   signatureValue=0x304402201e7703f63bff951917714e5fa813de5265f151a6802165ef0be5f1fe6c91225b02200ad06b41a5062b07ff3ad37c7d112e19575f0e14a9750fe95e615550b88b5fed



DER Base64:
MIIIyzCCAiUCAQIwggIeMCEGBioDh2cAADAXMBUGByoDh2cBAAAECjAxMDIwMzA0MDUwbgYGKgOHZwABMGQwEgYHKgOHZwEBAAwHSFNNLTEyMzAMBgcqA4dnAQEBAQH/MBQGByoDh2cBAQIMCU1vZGVsIEFCQzAQBgcqA4dnAQEEDAUzLjEuOTAYBgcqA4dnAQEDGA0yMDI1MDIwMzIyMzRaMIGyBgYqA4dnAAIwgacwLwYHKgOHZwECAAwkMjZkNzY1ZDgtMWFmZC00ZGZiLWEyOTAtY2Y4NjdkZGVjZmExMAwGByoDh2cBAgMBAQAwZgYHKgOHZwECAQRbMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEQiVI+I+3gv+17KN0RFLHKh5Vj71vc75eSOkyMsxFxbFsTNEMTLjVuKFxOelIgsiZJXKZNCX0FBmrfpCkKklCcjCBsgYGKgOHZwACMIGnMC8GByoDh2cBAgAMJDQ5YTk2YWNlLWUzOWEtNGZkMi1iZWMxLTEzMTY1YTk5NjIxYzAMBgcqA4dnAQIDAQH/MGYGByoDh2cBAgEEWzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEIlSPiPt4L/teyjdERSxyoeVY+9b3O+XkjpMjLMRcWxbEzRDEy41bihcTnpSILImSVymTQl9BQZq36QpCpJQnIwHwYFKgOGeAAwFjAUBgUqA4Z4AQwLcGFydGl0aW9uIDEwggaeMIIEejCCA0UwggNBMIICKaADAgECAhRZa7LL1EZqtYP6TqThmzBiZDtxDTANBgkqhkiG9w0BAQsFADAvMQ0wCwYDVQQKDARJRVRGMQ0wCwYDVQQLDARSQVRTMQ8wDQYDVQQDDAZBSyBSU0EwIBcNMjUwMTE3MTcxMzAzWhgPMjA1MjA2MDQxNzEzMDNaMC8xDTALBgNVBAoMBElFVEYxDTALBgNVBAsMBFJBVFMxDzANBgNVBAMMBkFLIFJTQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALD56BlDp66YkqreF8p8QPh0T+0vgUjmyOqie30AFUj7UZKrKLVsUGCxGMzRMeWUh0xsqYm1bCcpbwn7k6A03zLpfG/wmYz9jm9C3aWKzR+peYbxRPPRVNZ2UBdeaFSzqVIAO8Boh7hFWsKxn3svdlBOvJjslFVxsHiSFQ3canTKD7zTVJfOgVNNr5QYhEsTrqMfnVprlVe732Ge/U6Ify1CuN2LyYfq4b+Jyrhe4h41YwXfbAeog44+9BxZXczkPa/EkSPvTYq7qT05BeQCjXupFISidZbge0tu2ZLwd7Uk09z+fd1VSb58zo2gNc+gs/uPnkb3MrKoa0YBZcCPUxMCAwEAAaNTMFEwHQYDVR0OBBYEFIkZWV4O8Wn1y71H4TT84pjMaTCRMB8GA1UdIwQYMBaAFIkZWV4O8Wn1y71H4TT84pjMaTCRMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAGbNxMg9iFU20x2s5v1572pgAOVO5CXXLWZ2sM9wL7ObBm7Aosm7z2G/GYV0OtU1zpCw0qcfR9a0xnFTlRBOupbZZ/SMtjduN8mQKZNBqE4rxcPehCp9dUoJ74wYVRKHvUFRdzgUhDMwnqmEb7mqIKqwP0Ev+AVd/hqj4EjhJCFVaLoVH4k4EzF33UNgPJivo1910BvNpbuIOhURZHWm9ABlvJxZ+/Uohjqd7bJDR1J506ogT052OqLZCRbiQPupdEtgpww+p7VI9qjbGhLYrPxIh2gsicu7sJvdALuf+gRuIrgkhUPb2CIym50nyBsEsuPAOsKWzTID6eDyf/CSSLQwKwYJKoZIhvcNAQEKMB6gDTALBglghkgBZQMEAgGhDTALBgkqhkiG9w0BAQgEggEAm2rBky8c2FvvveBU4IRXfryRgbzwUXllinAOIlVvw/GTH1nclzTv4I3yBPz+VcZMapfo1SDljB9kCAtszhwI6I21EMBtaRSoGLcN+CMms3oqvlT6sFZ9dI4eguLelUysY8WrO8kv/5y4qmT7y4Pdi6y86WOS+R3UDuBQWK3OsR9c8MN5JB/UcJGKvO6nD9AcDLxk2WBn/lSexENzhlW8K89+W9VMFdXlrC9K0YDZc6fmAlEmzNK0XXjplEZiI3lZ73P0fprg+psMVRd7tvhnqQtB0O+3LBkvFaZlMdAwvIX+09E1rqQEXgJO8ugHUXUE0xPb6ksPcJ0FU7YHk7LcqjCCAhwwggG7MIIBtzCCAV2gAwIBAgIUB6npr/yEpH9d/wPt8w6Lo5AflbgwCgYIKoZIzj0EAwIwMDENMAsGA1UECgwESUVURjENMAsGA1UECwwEUkFUUzEQMA4GA1UEAwwHQUsgUDI1NjAgFw0yNTAxMTcxNzE0MjhaGA8yMDUyMDYwNDE3MTQyOFowMDENMAsGA1UECgwESUVURjENMAsGA1UECwwEUkFUUzEQMA4GA1UEAwwHQUsgUDI1NjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEIlSPiPt4L/teyjdERSxyoeVY+9b3O+XkjpMjLMRcWxbEzRDEy41bihcTnpSILImSVymTQl9BQZq36QpCpJQnKjUzBRMB0GA1UdDgQWBBRbcKeYF/ef9jfS9+PcRGwhCde71DAfBgNVHSMEGDAWgBRbcKeYF/ef9jfS9+PcRGwhCde71DAPBgNVHRMBAf8EBTADAQH/MAoGCCqGSM49BAMCA0gAMEUCIQCQfwSuP9Ms2gR8ki+iQQQNWaEfl/tRAd2usLJBYSEl6AIgJGzL/VWqOjeqD9aseiynBwHY9odjL4Wcfv2bOeo7uNUwEwYHKoZIzj0CAQYIKoZIzj0DAQcERjBEAiAedwP2O/+VGRdxTl+oE95SZfFRpoAhZe8L5fH+bJEiWwIgCtBrQaUGKwf/OtN8fREuGVdfDhSpdQ/pXmFVULiLX+0=

Appendix B.  Acknowledgements

   This specification is the work of a design team created by the chairs
   of the RATS working group.  This specification has been developed
   based on discussions in that design team and also with great amounts
   of input taken from discussions on the RATS mailing list.

Authors' Addresses

   Mike Ounsworth
   Entrust Limited
   2500 Solandt Road - Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: mike.ounsworth@entrust.com


   Jean-Pierre Fiset
   Crypto4A Inc.
   1550A Laperriere Ave
   Ottawa, Ontario  K1Z 7T2
   Canada
   Email: jp@crypto4a.com


   Hannes Tschofenig
   University of Applied Sciences Bonn-Rhein-Sieg
   Germany
   Email: Hannes.Tschofenig@gmx.net


   Henk Birkholz
   Fraunhofer SIT
   Email: henk.birkholz@ietf.contact


   Monty Wiseman
   Beyond Identity
   United States of America
   Email: monty.wiseman@beyondidentity.com


   Ned Smith
   Intel Corporation
   United States of America
   Email: ned.smith@intel.com
